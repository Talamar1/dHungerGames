# dHunger system
# Arena admins require op or dhunger.command permission
# Arenas are stored in dHungers_saves.yml and is 
# Editable and reloadable.
# Created by Talamar1

Hunger:
  type: world
  debug: false
  events:
    on server start:
    - run InitdHunger delay:10t
    - flag server dhg:!

    on dhg command:
    - determine passively fulfilled
    - if <context.args.size||0> == 0 {
      - inject dhunger_command_help
      - queue clear
      }
    - define arg1 <context.args.get[1].escaped>
    - define cmdList li@create|save|delete|spawn|set|breakable|lock|unlock|resize|board|disable|enable|start|stop|quit|select|list|clear|reload|lobby|vote
    - if <def[cmdList].contains[%arg1%]> {
      - if <context.server> || <player.has_permission[dhunger.%arg1%]||false> {
        - inject dhunger_command_%arg1%
        - queue clear
        }
        else {
        - narrate "<&6>You do not have permission to use the dhunger command."
        - queue clear
        }
      }
    - inject dhunger_command_help

    on player clicks wall_sign:
    - define sign <context.location.block>
    - wait 1t
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas]> {
      - if <yaml[dhunger_saves].read[dhg.arenas.%value%.board].as_list.contains[%sign%]> && <yaml[dhunger_saves].read[dhg.arenas.%value%.settings.enable]||false> {
        - if <player.has_flag[dhg.play]> determine cancelled
        - flag <player> dhg.play:%value%
        - inject dhunger_join
        - foreach stop
        }
      }
    
    on player joins:
    - if <player.has_flag[dhg]> {
      - flag <player> dhg:!
      }
    - teleport <player> <yaml[dhunger_saves].read[dhg.lobby]||<player.location.world.spawn_location>>
    
    on player quits:
    - if <player.has_flag[dhg.play]> {
      - define arena <player.flag[dhg.play]>
      - inject dhunger_remove_player
      - run dhunger_check_end_of_game def:%arena% instantly
      - flag <player> dhg:!
      }
    
    on player breaks block in notable cuboid:
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas]> {
      - if <context.cuboids.contains[cu@dhg_%value%]> {
        - if <yaml[dhunger_saves].read[dhg.arenas.%value%.settings.locked]||false> && <yaml[dhunger_saves].contains[dhg.arenas.%value%.settings.breakable]> {
          - if !<yaml[dhunger_saves].read[dhg.arenas.%value%.settings.breakable].contains[<context.material>]> {
            - determine cancelled
            - foreach stop
            }
            else {
            - run dhunger_task_block_track def:break|%value%|<context.location>|<context.material>
            - foreach stop
            }
          }
        }
      }

    on player places block in notable cuboid:
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas]> {
      - if <context.cuboids.contains[cu@dhg_%value%]> {
        - if <yaml[dhunger_saves].read[dhg.arenas.%value%.settings.locked]||false> && <yaml[dhunger_saves].contains[dhg.arenas.%value%.settings.placeable]> {
          - if !<yaml[dhunger_saves].read[dhg.arenas.%value%.settings.placeable].contains[<context.material>]> {
            - determine cancelled
            - foreach stop
            }
            else {
            - run dhunger_task_block_track def:place|%value%|<context.location>|<context.material>
            - foreach stop
            }
          }
        }
      }

    on player killed:
    - if <player.has_flag[dhg.play]> {
      - define arena <player.flag[dhg.play]>
      - narrate "<context.entity.name> was killed by <tern[<context.damager.is_player>]:<context.damager.name>||<context.cause>>" targets:<server.flag[dhg.%arena%.players].as_list>
      - inject dhunger_remove_player
      - run dhunger_check_end_of_game def:%arena% instantly
      - determine cancelled
      }
      
InitdHunger:
  type: task
  debug: false
  script:
    - inject dhunger_command_reload
    - inject dhunger_init_signs

dhunger_command_help:
  type: task
  debug: false
  script:
    - if <player.has_permission[dhunger.create]>    narrate "<&6>/dhg create <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.save]>      narrate "<&6>/dhg save"
    - if <player.has_permission[dhunger.delete]>    narrate "<&6>/dhg delete <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.spawn]>     narrate "<&6>/dhg spawn <&lb>add<&rb>/<&lb>del <&lt>id<&gt><&rb>/<&lb>list<&rb>/<&lb>show<&rb>"
    - if <player.has_permission[dhunger.breakable]> narrate "<&6>/dhg breakable <&lb>add<&rb>/<&lb>del<&rb>/<&lb>list<&rb>/<&lb>clear<&rb>"
    - if <player.has_permission[dhunger.set]>       narrate "<&6>/dhg set <&lt>setting<&gt> <&lt>value<&gt>"
    - if <player.has_permission[dhunger.board]>     narrate "<&6>/dhg board <&lb>add<&rb>/<&lb>del<&rb>"
    - if <player.has_permission[dhunger.lock]>      narrate "<&6>/dhg lock <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.unlock]>    narrate "<&6>/dhg unlock <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.disable]>   narrate "<&6>/dhg disable <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.enable]>    narrate "<&6>/dhg enable <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.start]>     narrate "<&6>/dhg start <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.stop]>      narrate "<&6>/dhg stop <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.quit]>      narrate "<&6>/dhg quit"
    - if <player.has_permission[dhunger.select]>    narrate "<&6>/dhg select <&lt>arena name<&gt>"
    - if <player.has_permission[dhunger.resize]>    narrate "<&6>/dhg resize"
    - if <player.has_permission[dhunger.list]>      narrate "<&6>/dhg list"
    - if <player.has_permission[dhunger.reload]>    narrate "<&6>/dhg reload"

dhunger_command_create:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> { 
      - narrate "<&6>/dhg create <&lt>arena name<&gt>" 
      - narrate "<&6>arena name - name for your arena" 
      - queue clear 
      }
    - if <context.args.get[2].is[!=].to[<context.args.get[2].escaped>]> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - define arg2 <context.args.get[2]>
    - if <yaml[hunger_saves].contains[dhg.arenas.%arg2%]> {
      - narrate "<&6>Arena with that name already exists."
      - queue clear
      }
    - if <player.selected_region.is[==].to[null]||true> { 
      - narrate "<&6>You don't have an area selected with WorldEdit wand." 
      - queue clear 
      }
    - narrate "Creating new arena"
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.cuboid:<player.selected_region>
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.settings.min_players:2
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.settings.locked:false
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.settings.max_players:20
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.settings.timer:120
    - yaml id:dhunger_saves set dhg.arenas.%arg2%.settings.restock:0
    - inject dhunger_command_save
    - note <player.selected_region> as:dhg_%arg2%
    - flag player dhg.edit:%arg2%
    - narrate "Arena created."

dhunger_command_save:
  type: task
  debug: false
  script:
    - narrate "Saving Hunger Games"
    - yaml savefile:dhunger_saves.yml id:dhunger_saves

dhunger_command_delete:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && !<player.has_flag[dhg.edit]> { 
      - narrate "<&6>/dhg delete <&lt>Arena Name<&gt>" 
      - narrate "<&6>Either select an arena or provide an arena name" 
      - queue clear 
      }
    - if <context.args.get[2].is[==].to[null]||true> define arena <player.flag[dhg.edit]>
      else define arena <context.args.get[2]>
    - if %arena% != <def[arena].escaped> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - narrate "Deleting selected arena."
    - yaml id:dhunger_saves set dhg.arenas.%arena%:!
    - flag player dhg.edit:!
    - inject dhunger_command_save

dhunger_command_reload:
  type: task
  debug: false
  script:
    - if <yaml.list.contains[dhunger_saves]> yaml unload id:dhunger_saves
    - if <server.has_file[dhunger_saves.yml]> { 
      - announce "<red><&lb>dHunger<&rb> <green>Loading Hunger Config File"
      - yaml load:dhunger_saves.yml id:dhunger_saves
      }
      else { 
      - announce "<red><&lb>dHunger<&rb> <green>Creating Hunger Config File"
      - yaml create id:dhunger_saves
      - yaml savefile:dhunger_saves.yml id:dhunger_saves
      }

dhunger_command_clear:
  type: task
  debug: false
  script:
    - yaml unload id:dhunger_saves
    - yaml create id:dhunger_saves
    - inject dhunger_command_save

dhunger_command_select:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> { 
      - narrate "<&6>/dhg select <&lt>arena name<&gt>" 
      - narrate "<&6>arena name - name for your arena" 
      - queue clear 
      }
    - if <context.args.get[2].is[!=].to[<context.args.get[2].escaped>]> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - define arg2 <context.args.get[2]>
    - if <yaml[dhunger_saves].list_keys[dhg.arenas].contains[%arg2%]> {
      - narrate "<&6>Selecting arena with name: %arg2%"
      - flag player dhg.edit:%arg2%
      }
      else {
      - narrate "<&6>Arena with that name not found."
      }


dhunger_command_resize:
  type: task
  debug: false
  script:
    - if !<player.has_flag[dhg.edit]> {
      - narrate "You don't have an arena selected."
      - queue clear
      }
    - if <player.selected_region.is[==].to[null]||true> { 
      - narrate "<&6>You don't have an area selected with WorldEdit wand." 
      - queue clear 
      }
    - narrate "Creating new arena"
    - yaml id:dhunger_saves set dhg.arenas.<player.flag[dhg.edit]>.cuboid:<player.selected_region>
    - inject dhunger_command_save
    - note <player.selected_region> as:dhg_<player.flag[dhg.edit]>
    - narrate "Arena resized."

dhunger_command_quit:
  type: task
  debug: false
  script:
    - if !<player.has_flag[dhg.play]> {
      - narrate "You don't appear to be in a game."
      - queue clear
      }
    - define arena <player.flag[dhg.play]>
    - narrate "Quitting arena game."
    - narrate "<player.name> quit the arena." targets:<server.flag[dhg.%arena%.players].as_list>
    - inject dhunger_remove_player
    - run dhunger_check_end_of_game def:%arena%

dhunger_command_spawn:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && <context.args.get[3].is[==].to[null]||true> { 
      - narrate "<&6>/dhg spawn add - add a new spawn"
      - narrate "<&6>/dhg spawn del <&lt>ID<&gt> - delete spawn at ID number (use list)"
      - narrate "<&6>/dhg spawn list - list all spawns"
      - narrate "<&6>/dhg spawn show - visually show spawns"
      - queue clear 
      }
    - if !<player.has_flag[dhg.edit]> {
      - narrate "You don't have an arena selected."
      - queue clear
      }
    - define arena <player.flag[dhg.edit]>
    - define arg2 <context.args.get[2]>
    - define arg3 <context.args.get[3]>
    - define settings li@add|del|list|show
    - if <def[settings].contains[%arg2%]> {
      - if <def[arg3].is[==].to[help]> {
        - inject dhunger_help_spawn_%arg2%
        }
        else {
        - inject dhunger_spawn_%arg2%
        }
      }
      else {
      - narrate "Invalid setting"
      }

dhunger_spawn_add:
  type: task
  debug: false
  script:
    - narrate "Adding new spawnpoint."
    - define scount <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.spawnpoint].size||0>
    - define spawnpoint l@<player.location.block.x.add[.5]>,<player.location.block.y>,<player.location.block.z.add[.5]>,<player.location.pitch>,<player.location.yaw>,<player.location.world.name>
    - yaml id:dhunger_saves set dhg.arenas.%arena%.spawnpoint.<def[scount].add[1]>:%spawnpoint%
    - inject dhunger_command_save

dhunger_spawn_del:
  type: task
  debug: false
  script:
    - if <context.args.get[3].is[==].to[null]||true> { 
      - narrate "<&6>/dhg spawn del <&lt>spawnpoint<&gt>" 
      - narrate "<&6>spawnpoint - ID Number for spawnpoint" 
      - queue clear 
      }
    - define arg3 <context.args.get[3]>
    - if <yaml[dhunger_saves].contains[dhg.arenas.%arena%.spawnpoint.%arg3%]> {
      - narrate "Removing spawnpoint."
      - yaml id:dhunger_saves set dhg.arenas.%arena%.spawnpoint.%arg3%:!
      - foreach <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.spawnpoint].numerical> {
        - define spawnpoint <yaml[dhunger_saves].read[dhg.arenas.%arena%.spawnpoint.%value%]>
        - yaml id:dhunger_saves set dhg.arenas.%arena%.spawnpoint.%value%:!
        - yaml id:dhunger_saves set dhg.arenas.%arena%.spawnpoint.%loop_index%:%spawnpoint%
        }
      - inject dhunger_command_save
      }
      else {
      - narrate "Could not find that spawnpoint."
      }

dhunger_spawn_list:
  type: task
  debug: false
  script:
    - narrate "Listing spawnpoints:"
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.spawnpoint].numerical> {
      - narrate "<&lt>%value%<&gt> <yaml[dhunger_saves].read[dhg.arenas.%arena%.spawnpoint.%value%]>"
      }

dhunger_spawn_show:
  type: task
  debug: false
  script:
    - narrate "Showing spawnpoints:"
    - repeat 10 {
      - foreach <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.spawnpoint].numerical> {
        - playeffect <yaml[dhunger_saves].read[dhg.arenas.%arena%.spawnpoint.%value%]> effect:red_dust qty:15
        }
      - wait 1s
      }

dhunger_command_breakable:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && ( <context.args.get[2].is[!=].to[clear]> && <context.args.get[3].is[==].to[null]||true> ) { 
        - narrate "<&6>/dhg breakable add - add block(s) to list"
        - narrate "<&6>/dhg breakable del - delete block(s) from list"
        - narrate "<&6>/dhg breakable list - list all blocks"
        - narrate "<&6>/dhg breakable clear - clear all blocks in list"
        - queue clear
      }
    - if !<player.has_flag[dhg.edit]> {
      - narrate "You don't have an arena selected."
      - queue clear
      }
    - define arena <player.flag[dhg.edit]>
    - define arg2 <context.args.get[2]>
    - define arg3 <context.args.get[3]||li@>
    - define settings li@add|del|list|clear
    - if <def[settings].contains[%arg2%]> inject dhunger_breakable_%arg2%
      else narrate "Invalid breakable command"

dhunger_breakable_add:
  type: task
  debug: false
  script:
    - if %arg3% == help {
      - narrate "<&6>/dhg breakable add <&lt>value<&pipe>value<&pipe>...<&gt>"
      - narrate "Where <&dq>value<&dq> is a <&pipe> separated list of block or material IDs."
      - queue clear
    }
    - foreach <el@val[%arg3%].as_list> {
      - define newmat <el@val[%value%].as_material||null>
      - if <def[newmat].is[!=].to[null]> {
        - narrate "%value% is %newmat%"
        - if !<yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.breakable].contains[%newmat%]> {
          - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.breakable:->:%newmat%
          }
          else {
          - narrate "Item already in list"
          }
        }
        else {
        - narrate "%value% is not a valid block or item"
        }
      }
    - inject dhunger_command_save

dhunger_breakable_del:
  type: task
  debug: false
  script:
    - if %arg3% == help {
      - narrate "<&6>/dhg breakable del <&lt>value<&pipe>value<&pipe>...<&gt>"
      - narrate "Where <&dq>value<&dq> is a <&pipe> separated list of block or material IDs."
      - queue clear
    }
    - foreach <def[arg3]> {
      - define newmat <el@val[%value%].unescaped.as_material||null>
      - if <def[newmat].is[!=].to[null]> {
        - narrate "%newmat% is valid"
        - if <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.breakable].contains[%newmat%]> {
          - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.breakable:<-:%newmat%
          }
        }
        else {
        - narrate "%value% is not a valid block or item"
        }
      }
    - inject dhunger_command_save

dhunger_breakable_list:
  type: task
  debug: false
  script:
    - if <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.breakable].size||0> > 0 {
      - define blocklist <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.breakable].replace[li@]>
      - narrate "%blocklist%"
      }

dhunger_breakable_clear:
  type: task
  debug: false
  script:
    - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.breakable:!
    - inject dhunger_breakable_add

dhunger_command_lock:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && !<player.has_flag[dhg.edit]> { 
      - narrate "<&6>/dhg locked <&lt>Arena ID<&gt>" 
      - narrate "<&6>Either select an arena or provide an arena name" 
      - queue clear 
      }
    - if <context.args.get[2].is[==].to[null]||true> define arena <player.flag[dhg.edit]>
      else define arena <context.args.get[2]>
    - if %arena% != <def[arena].escaped> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - if <yaml[dhunger_saves].list_keys[dhg.arenas].contains[%arena%]> {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.locked:true
      - narrate "<&6>Locking arena with name: %arena%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>Arena with that name not found."
      }

dhunger_command_unlock:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && !<player.has_flag[dhg.edit]> { 
      - narrate "<&6>/dhg locked <&lt>Arena ID<&gt>" 
      - narrate "<&6>Either select an arena or provide an arena name" 
      - queue clear 
      }
    - if <context.args.get[2].is[==].to[null]||true> define arena <player.flag[dhg.edit]>
      else define arena <context.args.get[2]>
    - if %arena% != <def[arena].escaped> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - if <yaml[dhunger_saves].list_keys[dhg.arenas].contains[%arena%]> {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.locked:false
      - narrate "<&6>Unlcking arena with name: %arena%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>Arena with that name not found."
      }

dhunger_command_enable:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && !<player.has_flag[dhg.edit]> { 
      - narrate "<&6>/dhg enable <&lt>Arena ID<&gt>" 
      - narrate "<&6>Either select an arena or provide an arena name" 
      - queue clear 
      }
    - if <context.args.get[2].is[==].to[null]||true> define arena <player.flag[dhg.edit]>
      else define arena <context.args.get[2]>
    - if %arena% != <def[arena].escaped> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - if <yaml[dhunger_saves].list_keys[dhg.arenas].contains[%arena%]> {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.enable:true
      - narrate "<&6>Enabling arena with name: %arena%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>Arena with that name not found."
      }

dhunger_command_disable:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> && !<player.has_flag[dhg.edit]> { 
      - narrate "<&6>/dhg enable <&lt>Arena ID<&gt>" 
      - narrate "<&6>Either select an arena or provide an arena name" 
      - queue clear 
      }
    - if <context.args.get[2].is[==].to[null]||true> define arena <player.flag[dhg.edit]>
      else define arena <context.args.get[2]>
    - if %arena% != <def[arena].escaped> { 
      - narrate "<&6>That value doesn't look right." 
      - queue clear 
      }
    - if <yaml[dhunger_saves].list_keys[dhg.arenas].contains[%arena%]> {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.enable:false
      - narrate "<&6>Disabling arena with name: %arena%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>Arena with that name not found."
      }
    
dhunger_command_list:
  type: task
  debug: false
  script:
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas]> {
      - narrate "<&6>Arena: %value%"
      }

dhunger_command_set:
  type: task
  debug: false
  script:
    - if <context.args.get[2].is[==].to[null]||true> || <context.args.get[2].is[==].to[help]||true> { 
      - narrate "<&6>/dhg set <&lt>setting<&gt> <&lt>value<&gt>"
      - narrate "<&6>setting - setting to change" 
      - narrate "<&6><&sp><&sp><&sp>restock"
      - narrate "<&6><&sp><&sp><&sp>min_players"
      - narrate "<&6><&sp><&sp><&sp>max_players"
      - narrate "<&6><&sp><&sp><&sp>lightning"
      - narrate "<&6><&sp><&sp><&sp>lightning_delay"
      - narrate "<&6><&sp><&sp><&sp>countdown"
      - narrate "<&6><&sp><&sp><&sp>timer"
      - narrate "<&6><&sp><&sp><&sp>tier1"
      - narrate "<&6><&sp><&sp><&sp>tier2"
      - narrate "<&6>value - value to assign to setting" 
      - queue clear 
      }
    - if !<player.has_flag[dhg.edit]> {
      - narrate "You don't have an arena selected."
      - queue clear
      }
    - define arena <player.flag[dhg.edit]>
    - define arg2 <context.args.get[2]>
    - define arg3 <context.args.get[3]||help>
    - define settings li@restock|min_players|max_players|lightning|lightning_delay|countdown|timer|tier1|tier2
    - if <def[settings].contains[%arg2%]> {
      - if <def[arg2].contains[tier]> {
        - define tier %arg2%
        - define arg2 tier
        }
      - if <def[arg3].is[==].to[help]> {
        - inject dhunger_help_set_%arg2%
        }
        else {
        - inject dhunger_setting_%arg2%
        }
      }
      else {
      - narrate "Invalid setting"
      - queue clear
      }
dhunger_setting_restock:
  type: task
  debug: false
  script:
    - if %arg3% != help && <def[arg3].matches[integer]> {
      - yaml id:dhunger_saves set dhg.arenas.arenas.%arena%.settings.restock:<def[arg3]>
      - narrate "<&6>Changing RESTOCK on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set restock <&lt>value<&gt>"
      - narrate "Where <&dq>value<&dq> is a number equal to the amount of time between restocks."
      - narrate "Use 0 for no restocking."
      }

dhunger_setting_tier:
  type: task
  debug: false
  script:
    - if %arg3% == help {
      - narrate "<gold>/dhg set tier<&lb>1<&pipe>2<&rb> (add<&pipe>del) (item)(<&pc>percent)(<&ns>qty)"
      - narrate "<gold><&sp><&sp><&sp>1 or 2 <green>the tier you want to modify"
      - narrate "<gold><&sp><&sp><&sp>add or del <green>(optional<&cm> leaving it out overwites the whole list)"
      - narrate "<gold><&sp><&sp><&sp>item <green>the item to modify"
      - narrate "<gold><&sp><&sp><&sp><&pc>value <green>the chance item will be in chest (optional<&cm> default 25)"
      - narrate "<gold><&sp><&sp><&sp><&ns>value <green>the max quantity to be in a chest (optional<&cm> default 1)"
      }
      else if %arg3% == clear {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.%tier%:!
      - inject dhunger_command_save
      - queue clear
      }
      else if %arg3% == list {
      - narrate "%tier% item list"
      - if !<yaml[dhunger_saves].contains[dhg.arenas.%arena%.settings.%tier%]> queue clear
      - foreach <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.settings.%tier%]> {
        - define itemvals <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.%tier%.%value%].as_list>
        - narrate "<gold><&sp><&sp><&sp><def[value]><&sp><green><def[itemvals].get[1].pad_left[3]><&pc><&sp><white>qty<&co><def[itemvals].get[2]>"
        }
      - queue clear
      }
    - foreach <context.args.get[4]||li@> {
      - define newitem <el@val[%value%].before[%].before[#].as_item||null>
      - define percent <el@val[%value%].after[%].before[#].as_int||25>
      - define qty <el@val[%value%].after[#].before[%].as_int||1>
      - if <def[newitem].is[!=].to[null]> {
        - narrate "%value% is %newitem% at %percent% qty %qty%"
        - if %arg3% == add {
          - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.%tier%.%newitem%:li@%percent%|%qty%
          }
          else {
          - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.%tier%.%newitem%:!
          }
        }
        else {
        - narrate "%value% is not a valid item"
        }
      }
    - inject dhunger_command_save

dhunger_setting_min_players:
  type: task
  debug: false
  script:
    - if <def[arg3].matches[integer]> && <def[arg3].is[OR_MORE].than[2]> {
      - yaml id:dhunger_saves set dhg.arenas.arenas.%arena%.settings.min_players:<def[arg3]>
      - narrate "<&6>Changing MIN_PLAYERS on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set min_players <&lt>value<&gt>"
      - narrate "Where <&dq>value<&dq> is the minimum number of players for a game."
      - narrate "Default is 2."
      }

dhunger_setting_max_players:
  type: task
  debug: false
  script:
    - if <def[arg3].matches[integer]> && <def[arg3].is[OR_MORE].than[<yaml[dhunger_saves].read[dhg.arenas.arenas.%arena%.settings.min_players]>]> {
      - yaml id:dhunger_saves set dhg.arenas.arenas.%arena%.settings.restock:<def[arg3]>
      - narrate "<&6>Changing RESTOCK on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set max_players <&lt>value<&gt>"
      - narrate "Where <&dq>value<&dq> is the maximum number of players for a game."
      - narrate "Default is 20."
      }

dhunger_setting_lightning:
  type: task
  debug: false
  script:
    - define allowed li@always|2|off
    - if <def[allowed].contains[%arg3%]> {
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.lightning:%arg3%
      - narrate "<&6>Changing LIGHTNING on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set lightning <&lt>value<&gt>"
      - narrate "<&6>Available values are: always, 2 or off"
      - narrate "<&6>Always = Use lightning through the whole game"
      - narrate "<&6>2 = Use lightning when game is down to 2 players"
      - narrate "<&6>off = Don't use lightning at all"
      }

dhunger_setting_lightning_delay:
  type: task
  debug: false
  script:
    - if <def[arg3].is[matches].to[integer]> { 
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.lightning_delay:%arg3%
      - narrate "<&6>Changing LIGHTNING_DELAY on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set lightning_delay <&lt>value<&gt>"
      - narrate "<&6>value = Seconds between lightning strikes."
      - narrate "<&6>Available values are numbers > 0 "
      }

dhunger_setting_countdown:
  type: task
  debug: false
  script:
    - if <def[arg3].is[matches].to[integer]> { 
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.countdown:%arg3%
      - narrate "<&6>Changing COUNTDOWN on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set countdown <&lt>value<&gt>"
      - narrate "<&6>Number = Seconds to countdown at start of game."
      - narrate "<&6>Available values are numbers > 0 "
      - narrate "<&6>Default is 10"
      }

dhunger_setting_timer:
  type: task
  debug: false
  script:
    - if <def[arg3].is[matches].to[integer]> { 
      - yaml id:dhunger_saves set dhg.arenas.%arena%.settings.timer:%arg3%
      - narrate "<&6>Changing TIMER on arena <&lt>%arena%<&gt> with value: %arg3%"
      - inject dhunger_command_save
      }
      else {
      - narrate "<&6>/dhg set countdown <&lt>value<&gt>"
      - narrate "<&6>Number = Timer to wait for players to join."
      - narrate "<&6>Available values are numbers > 0 "
      - narrate "<&6>Default is 30"
      }

dhunger_command_board:
  type: task
  debug: false
  script:
    - if !<player.has_flag[dhg.edit]> {
      - narrate "You don't have an arena selected."
      - queue clear
      }
    - define arena <player.flag[dhg.edit]>
    - define arg2 <context.args.get[2]>
    - define settings li@add|del|reset
    - if <def[settings].contains[%arg2%]> {
      - if <def[arg2].is[==].to[help]> inject dhunger_help_board_%arg2%
        else inject dhunger_board_%arg2%
      }
      else {
      - narrate "<&6>/dhg board <&lb>add<&rb><&pipe><&lb>del<&rb><&pipe><&lb>reset<&rb>"
      - narrate "add - Add a sign board"
      - narrate "del - Delete the arena sign configuration"
      - narrate "reset - Reset a board"
      }
      
dhunger_board_add:
  type: task
  debug: false
  script:
    - define signs <player.selected_region.get_blocks.filter[material.bukkit_enum.is[==].to[wall_sign]]||0>
    - if <def[signs].size.is[OR_MORE].to[3]> {
      - narrate "Found your sign"
      - define sdir <def[signs].get[1].material.data>
      - define slist li@<def[signs].get[1]>
      - define signs <def[signs].remove[1]>
      - narrate "Direction %sdir%"
      # West
      - foreach %signs% {
        - define nsign %value%
        - define found false
        - foreach <def[slist]> {
          - if <def[nsign].as_location.y.is[MORE].than[<def[value].as_location.y>]> {
            - define slist <def[slist].insert[%nsign%].at[<def[loop_index]>]>
            - define found true
            - foreach stop
            }
            # West Facing
            else if <def[sdir].is[==].to[4]> {
            - if <def[nsign].as_location.z.is[LESS].than[<def[value].as_location.z>]> {
              - define slist <def[slist].insert[%nsign%].at[<def[loop_index]>]>
              - define found true
              - foreach stop
              }
            }
            # East Facing
            else if <def[sdir].is[==].to[5]> {
            - if <def[nsign].as_location.z.is[MORE].than[<def[value].as_location.z>]> {
              - define slist <def[slist].insert[%nsign%].at[<def[loop_index]>]>
              - define found true
              - foreach stop
              }
            }
            # North Facing
            else if <def[sdir].is[==].to[2]> && <def[nsign].as_location.y.is[==].than[<def[value].as_location.y>]> {
            - if <def[nsign].as_location.x.is[MORE].than[<def[value].as_location.x>]> {
              - define slist <def[slist].insert[%nsign%].at[<def[loop_index]>]>
              - define found true
              - foreach stop
              }
            }
            # South Facing
            else if <def[sdir].is[==].to[3]> {
            - if <def[nsign].as_location.x.is[LESS].than[<def[value].as_location.x>]> {
              - define slist <def[slist].insert[%nsign%].at[<def[loop_index]>]>
              - define found true
              - foreach stop
              }
            }
          }
        - if !<def[found]> {
          - if <def[sdir].is[==].to[4]> || <def[sdir].is[==].to[3]> {
            - define slist <def[slist].insert[%nsign%].at[<def[slist].size.add[1]>]>
            }
            else {
            - define slist <def[slist].insert[%nsign%].at[<def[slist].size>]>
            }
          }
        }
      - yaml id:dhunger_saves set dhg.arenas.%arena%.board:%slist%
      - inject dhunger_command_save
      - define arena <player.flag[dhg]>
      - inject dhunger_task_reset_sign
      }
      else {
      - narrate "sign wall missing or not big enough"
      }

dhunger_board_del:
  type: task
  debug: false
  script:
    - yaml id:dhunger_saves set dhg.arenas.%arena%.board:!
    - inject dhunger_command_save
    - narrate "The board in arena %arena% was removed."

dhunger_board_reset:
  type: task
  debug: false
  script:
    - define sign <yaml[dhunger_saves].read[dhg.arenas.%arena%.board]||li@>
    - if <def[sign].size> > 2 {
      - define p_list <tern[<server.has_flag[dhg.%arena%.players]>]:<server.flag[dhg.%arena%.players].parse[name].alphanumeric>||li@>
      - define p_count <def[p_list].size>
      - define alive <server.get_online_players_flagged[dhg.play].filter[flag[dhg.play].is[==].to[%arena%]].size>
      # Set panel 1
      - sign type:automatic "Hunger Game|%arena%|<&lt>Click to Join<&gt>" <def[sign].get[1]>
      # Set panel 2
      - sign type:automatic "%arena%|<white>%p_count%<&0>/<&2>%alive%<&0>/<&4><server.flag[dhg.%arena%.dead].size||0><&0>/<&0><yaml[dhunger_saves].read[dhg.arenas.%arena%.max_players].get[1]||20>" <def[sign].get[2]>
      # Clear remaining boards
      - define dead_list <server.flag[dhg.%arena%.dead]||li@>
      - define p_sign li@
      - foreach <def[sign].get[3].to[<def[sign].size>]> {
        - if <def[p_list].size> = 0 {
          - sign type:automatic "" %value%
          - foreach next
          }
        - define l_sign %value%
        - define p_sign <def[p_list].get[1].to[3]||li@>
        - foreach p_sign {
          - if <def[dead_list].contains[%value%]> define p_sign <def[p_sign].remove[%loop_index%].insert[<red>%value%].at[%loop_index%]>
          }
        - define p_list <def[p_list].remove[1|2|3]||li@>
        - sign type:automatic "%p_sign%" %l_sign%
        }
      }

dhunger_command_lobby:
  type: task
  debug: false
  script:
    - yaml id:dhunger_saves set dhg.lobby:l@<player.location.block.x.add[.5]>,<player.location.block.y>,<player.location.block.z.add[.5]>,<player.location.pitch>,<player.location.yaw>,<player.location.world.name>
    - inject dhunger_command_save

dhunger_init_signs:
  type: task
  debug: false
  script:
    - foreach <yaml[dhunger_saves].list_keys[dhg.arenas]> {
      - define arena %value%
      - inject dhunger_board_reset
      }

dhunger_join:
  type: task
  debug: false
  script:
    - narrate "Joining game"
    - define arena <player.flag[dhg.play]>
    - define spawnpoints <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.spawnpoint].numerical>
    - define order <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.order]||ordered>
    - define ingame false
    - if <def[order].matches[random]> {
      - while <def[spawnpoints].size> > 0 {
        - define randomnum <util.random.int[1].to[<def[spawnpoints].size>]>
        - define spawnpt <yaml[dhunger_saves].read[dhg.arenas.%arena%.spawnpoint.<def[spawnpoints].get[%randomnum%]>]>
        - if <def[spawnpt.find.players.within[1].size> > 0 {
          - define spawnpoints <def[spawnpoints].remove[%randomnum%]>
          }
          else {
          - define ingame true
          - while stop
          }
        }
      }
      else {
      - foreach %spawnpoints% {
        - define spawnpt <yaml[dhunger_saves].read[dhg.arenas.%arena%.spawnpoint.%value%]>
        - if <def[spawnpt].find.players.within[1].size> > 0 {
          - foreach next
          }
          else {
          - define ingame true
          - foreach stop
          }
        }
      }
    - if !<def[ingame]> {
      - narrate "Game spawns are full"
      }
      else {
#      - run dhunger_task_barricade def:up|%arena%|%spawnpt%
      - flag server dhg.%arena%.players:->:<player>
      - inject dhunger_remove_inventory
      - define state up
      - inject dhunger_task_barricade
      - teleport <player> %spawnpt%
      - adjust <player> gamemode:survival
      - narrate "<player.name> is joining the game." targets:<server.flag[dhg.%arena%.players].exclude[<player>]>
      - inject dhunger_board_reset
      - if <server.has_flag[dhg.%arena%.timer]> {
        - flag server dhg.%arena%.timer:<yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.timer]||30>
        }
        else {
        - run dhunger_task_checkstart def:%arena%
        }
      }

dhunger_task_checkstart:
  type: task
  debug: false
  script:
    - wait 1t
    - define arena %1%
    - define timer <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.timer]||30>
    - flag server dhg.%arena%.timer:%timer%
    - define steps li@%timer%|15|10|5|1
    - if <def[timer].is[MORE].than[30]> {
      - repeat <def[timer].div[30].round_up> {
        - define steps <def[steps].insert[<def[value].mul[30]>].at[0]>
        }
      - define steps <def[steps].numerical.deduplicate>
      }
    - while <server.has_flag[dhg.%arena%.timer]> {
      - if <server.flag[dhg.%arena%.players].size||0> == 0 {
        - run dhunger_check_end_of_game def:%arena%
        - while stop
        }
      - if <def[steps].contains[<server.flag[dhg.%arena%.timer].as_int>]> {
        - if <server.flag[dhg.%arena%.players].size> >= <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.min_player]||2> {
          - narrate "Game will start in: <server.flag[dhg.%arena%.timer].as_int> seconds" targets:<server.flag[dhg.%arena%.players].as_list>
          }
          else {
          - narrate "Waiting for players...<server.flag[dhg.%arena%.timer].as_int> seconds to go." targets:<server.flag[dhg.%arena%.players].as_list>
          }
        }
        else if <server.flag[dhg.%arena%.timer].is[or_less].than[0]> {
        - if <server.flag[dhg.%arena%.players].size.is[less].than[<yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.min_player]||2>]> {
          - foreach <server.flag[dhg.%arena%.players].as_list> {
            - run dhunger_remove_player player:%value%
            }
          - narrate "Not enough players, cancelling game" targets:<server.flag[dhg.%arena%.players].as_list>
          - run dhunger_check_end_of_game def:%arena%
          - flag server dhg.%arena%:!
          - while stop
          }
        - run dhunger_game_start def:%arena% instantly
        - while stop
        }
      - flag server dhg.%arena%.timer:--
      - wait 1s
      }

dhunger_game_start:
  type: task
  debug: false
  script:
    - define arena %1%
    - repeat <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.countdown]||10> {
      - define count <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.countdown]||10.sub[value].add[1]>
      - narrate "Beginning in <red>%count%" targets:<server.flag[dhg.%arena%.players].as_list>
      - wait 1s
      }
    - run dhunger_stock_chests def:%arena%
    - define state down
    - foreach <server.flag[dhg.%arena%.players].as_list> {
      - define spawnpt <def[value].location.block>
      - inject dhunger_task_barricade
      }
    - narrate "<green>GO!" targets:<server.flag[dhg.%arena%.players].as_list>

dhunger_remove_inventory:
  type: task
  debug: false
  script:
    - narrate "Remove Inventory"
    - define equipment <player.flag[dhg.equipment]||li@>
    - yaml id:dhunger_saves set 'dhg.player.<player.uuid>.equipment:<player.equipment>'
    - yaml id:dhunger_saves set 'dhg.player.<player.uuid>.inventory:<player.inventory.list_contents>'
    - inventory clear d:<player>
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - inject dhunger_command_save

dhunger_replace_inventory:
  type: task
  debug: false
  script:
    - narrate "Replace Inventory"
    - inventory clear d:<player>
    - define equipment <yaml[dhunger_saves].read[dhg.player.<player.uuid>.equipment]||li@>
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - inventory set 'd:<player.inventory>' 'o:<yaml[dhunger_saves].read[dhg.player.<player.uuid>.inventory]||li@>'
    - yaml id:dhunger_saves set 'dhg.player.<player.uuid>:!'
    - inject dhunger_command_save

dhunger_remove_player:
  type: task
  debug: false
  script:
    - wait 1t
    - drop <player.inventory.list_contents>
    - define arena <player.flag[dhg.play]>
    - teleport <player> <yaml[dhunger_saves].read[dhg.lobby]||<player.location.world.spawn_location>>
    - inject dhunger_replace_inventory
    - flag server dhg.%arena%.dead:->:<player.name>
    - inject dhunger_board_reset
    - flag player dhg.play:!
    - narrate "Removing player <player.name> flag"
    - adjust <player> health:20
    - adjust <player> food_level:100
    - adjust <player> saturation:100

dhunger_check_end_of_game:
  type: task
  debug: false
  script:
    - define arena %1%
    - wait 1t
    - narrate "End of game"
    - if <server.get_online_players_flagged[dhg.play].filter[flag[dhg.play].is[==].to[%arena%]].size.is[==].to[1]> {
      - define winner <server.get_online_players_flagged[dhg.play].filter[flag[dhg.play].is[==].to[%arena%]].get[1]>
      - run dhunger_remove_player player:%winner% instantly
      - announce "<green><def[winner].name> has won the hunger game in %arena%"
      }
    - run dhunger_task_block_rollback def:%arena%
    - remove <cu@dhg_%arena%.list_entities[dropped_item]>
    - narrate "clearing flags"
    - flag server dhg.%arena%:!
    - narrate "resetting boards"
    - inject dhunger_board_reset

dhunger_stock_chests:
  type: task
  debug: false
  script:
    - define arena %1%
    - foreach li@tier1|tier2 {
      - define tier %value%
      - if !<yaml[dhunger_saves].contains[dhg.arenas.%arena%.settings.%tier%]> foreach next
      - define type <tern[<def[tier].is[==].to[tier1]>]:m@chest||m@trapped_chest>
      - define chests <cu@dhg_%arena%.get_blocks[%type%,1|%type%,2|%type%,3|%type%,4|%type%,5|%type%,6]>
      - foreach %chests% {
        - define chest %value%
        - define additems li@
        - foreach <yaml[dhunger_saves].list_keys[dhg.arenas.%arena%.settings.%tier%]> {
          - define itemvals <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.%tier%.%value%].as_list>
          - if <util.random.int[1].to[100].is[OR_LESS].than[<def[itemvals].get[1]||25>]> {
            - define additems <def[additems].insert[%value%[quantity=<util.random.int[1].to[<def[itemvals].get[2]||1>]>]].at[1]>
            }
          }
        - inventory set d:%chest% o:%additems%
        }
      }

dhunger_task_block_track:
  type: task
  debug: false
  script:
    - define action %1%
    - define arena %2%
    - define location %3%
    - define mat %4%
    - yaml id:dhunger_saves set dhg.arenas.%arena%.track.%action%:->:li@%location%|%mat%
    - inject dhunger_command_save
    
dhunger_task_block_rollback:
  type: task
  debug: false
  script:
    - define arena %1%
    - if <yaml[dhunger_saves].contains[dhg.arenas.%arena%.track]> {
      - if <yaml[dhunger_saves].contains[dhg.arenas.%arena%.track.break]> {
        - foreach <yaml[dhunger_saves].read[dhg.arenas.%arena%.track.break]> {
          - modifyblock <def[value].get[1]> <def[value].get[2]>
          }
        }
      - if <yaml[dhunger_saves].contains[dhg.arenas.%arena%.track.place]> {
        - foreach <yaml[dhunger_saves].read[dhg.arenas.%arena%.track.place]> {
          - modifyblock <def[value].get[1]> m@air
          }
        }
      - yaml id:dhunger_saves set dhg.arenas.%arena%.track:!
      - inject dhunger_command_save
      }

dhunger_task_barricade:
  type: task
  debug: false
  script:
#    - define state <tern[<def[state]||false>]:<def[state]>||<def[1]||up>>
#    - define arena <tern[<def[arena]||false>]:<def[arena]>||<def[2]||false>>
#    - define spawnpt <tern[<def[spawnpt]||false>]:<def[spawnpt]>||<def[3]||up>>
    - define barricade li@
    - define blocktype <yaml[dhunger_saves].read[dhg.arenas.%arena%.settings.barrier]||m@barrier>
    - foreach li@0|1|2 {
      - define y %value%
      - foreach li@-1|0|1 {
        - define x %value%
        - foreach li@-1|0|1 {
          - define z %value%
          - if %x% == 0 && %z% == 0 {
            - foreach next
            }
          - define block <def[spawnpt].add[%x%,%y%,%z%]>
          - if ( <def[state].is[==].to[up]> && <def[block].material.is[==].to[m@air]> ) || ( <def[state].is[==].to[down]> && <def[block].material.is[==].to[%blocktype%]> ) {
            - define barricade <def[barricade].insert[%block%].at[1]>
            }
          }
        }
      }
    - if <def[barricade].size.is[more].than[0]> modifyblock %barricade% <tern[<def[state].is[==].to[down]>]:m@air||%blocktype%> no_physics
